import logging
import shutil
from contextlib import redirect_stderr, redirect_stdout
from pathlib import Path
from typing import Any

from astropy.table import Table
from astropy.time import Time
from celery import current_task
from fink_utils.slack_bot.bot import init_slackbot
from sqlalchemy.orm import Session
from yarl import URL

from grandma_gcn.database.gw_db import GW_alert as GWDB_alert
from grandma_gcn.gcn_stream.gw_alert import GW_alert
from grandma_gcn.slackbot.gw_message import (
    build_gwemopt_message,
    build_gwemopt_results_message,
    new_alert_on_slack,
    post_image_on_slack,
)
from grandma_gcn.worker.celery_app import celery, with_session
from grandma_gcn.worker.gwemopt_init import GalaxyCatalog, init_gwemopt
from grandma_gcn.worker.owncloud_client import OwncloudClient


def setup_task_logger(
    task_name: str, log_path: Path, task_id: str
) -> tuple[logging.Logger, Path]:
    """
    Configure a logger to log into a separate file for each task.

    Parameters
    ----------
    task_name : str
        The name of the task.
    log_path : Path
        The path where the log files will be stored.
    task_id : str
        The unique identifier for the task, used to create a unique log file name.

    Returns
    -------
    tuple[logging.Logger, Path]
        A tuple containing the logger and the path to the log file.
    """
    logger = logging.getLogger(f"gcn_stream.consumer.worker.{task_id}")
    logger.setLevel(logging.INFO)

    # Create a file handler for the task
    log_file = log_path / f"{task_name}_{task_id}.log"
    log_file.parent.mkdir(
        parents=True, exist_ok=True
    )  # Create the logs directory if it doesn't exist
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(logging.INFO)

    # Create a formatter and add it to the handler
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    file_handler.setFormatter(formatter)

    # Add the handler to the logger
    if not logger.handlers:  # Avoid adding multiple handlers
        logger.addHandler(file_handler)

    return logger, log_file


def run_gwemopt(
    gw_alert: GW_alert,
    telescopes: list[str],
    nb_tiles: list[str],
    nside: int,
    path_output: Path,
    observation_strategy: GW_alert.ObservationStrategy,
    logger: logging.Logger,
    path_galaxy_catalog: Path | None,
    galaxy_catalog: GalaxyCatalog | None,
) -> tuple[Table, Any]:
    """
    Run the gwemopt observation plan.

    Parameters
    ----------
    gw_alert : GW_alert
        The GW_alert object containing the alert information.
    telescopes : list[str]
        List of telescopes to use for the observation plan.
    nside : int
        The nside parameter for the skymap.
    path_output : Path
        Path to the output directory.
    observation_strategy : GW_alert.ObservationStrategy
        The observation strategy to use.
    logger : logging.Logger
        Logger to use for logging. If None, a new logger will be created.
    path_galaxy_catalog : Path | None
        Path to the galaxy catalog directory.
    galaxy_catalog : GalaxyCatalog | None
        The galaxy catalog to use.

    Returns
    -------
    tuple[Table, Any]
        - tiles_tables: the table of tiles generated by gwemopt
        - galaxies_table: the table of galaxies generated by gwemopt
    """
    logger.info("Flattening the skymap...")
    flat_map = gw_alert.flatten_skymap(nside)
    logger.info("Flat map created. Initializing gwemopt...")

    params, map_struct = init_gwemopt(
        flat_map,
        convert_to_nested=False,
        exposure_time=[30 for _ in range(len(nb_tiles))],
        max_nb_tile=nb_tiles,
        nside=nside,
        do_3d=False,
        do_plot=True,
        do_observability=True,
        do_footprint=True,
        do_movie=True,
        moon_check=False,
        do_reference=True,
        path_catalog=path_galaxy_catalog,
        galaxy_catalog=galaxy_catalog,
    )

    logger.info("gwemopt initialized. Running observation plan...")
    obs_plan_results = gw_alert.run_observation_plan(
        telescopes,
        params,
        map_struct,
        str(path_output),
        observation_strategy,
    )
    logger.info("Observation plan completed.")

    return obs_plan_results


def table_to_custom_ascii(telescope: str, table: Table | None) -> str:
    """
    Convert a table returned by gwemopt to a custom ASCII format for the grandma owncloud.

    Parameters
    ----------
    telescope : str
        The name of the telescope.
    table : Table | None
        The table containing the observation plan data. If None, a message indicating no tiles will be returned.

    Returns
    -------
    str
        The formatted string in the custom ASCII format.
    """
    lines = [f"# {telescope}"]
    lines.append("rank_id       tile_id       RA       DEC       Prob   Timeobs")

    if not table:
        lines.append("# No tiles to observe")
        return "\n".join(lines)

    for row in table:
        rank_id = row["rank_id"]
        tile_id = row["tile_id"]
        ra = row["RA"] * 180 / 3.141592653589793  # rad → deg
        dec = row["DEC"] * 180 / 3.141592653589793  # rad → deg
        prob = row["Prob"]
        timeobs = Time(row["Timeobs"]).iso  # format ISO, eg. 2025-05-27 08:49:22.577

        # truncate ms to 3 digits
        timeobs = timeobs[:23]

        # Format the line with fixed spacing
        line = (
            f"{rank_id:<4} {tile_id:<8} {ra:<10.4f} {dec:<10.4f} {prob:<8.4f} {timeobs}"
        )
        lines.append(line)

    return "\n".join(lines)


def push_gwemopt_product_on_owncloud(
    owncloud_client: OwncloudClient,
    path_gwemopt: Path,
    owncloud_url: URL,
    pattern: str = "*.png",
):
    """
    Push the gwemopt product to ownCloud.

    Parameters
    ----------
    owncloud_client : OwncloudClient
        The ownCloud client to use for uploading files.
    path_gwemopt : Path
        The local path where the gwemopt product is stored.
    owncloud_url : URL
        The URL of the ownCloud instance where the product will be uploaded.
    pattern : str
        The pattern to match files to upload. Default is "*.png".
    """
    list_plot_path = path_gwemopt.glob(pattern)
    for f in list_plot_path:
        owncloud_filename = f.name
        owncloud_client.put_file(f, owncloud_url, owncloud_filename)
        owncloud_client.logger.info(
            f"File {owncloud_filename} successfully uploaded to {owncloud_url}"
        )
    owncloud_client.logger.info(
        f"All gwemopt products successfully uploaded to {owncloud_url}"
    )


@celery.task(name="gwemopt_task")
@with_session
def gwemopt_task(
    session: Session,
    telescopes: list[str],
    nb_tiles: list[int],
    nside: int,
    slack_channel: str,
    channel_id: str,
    owncloud_config: dict[str, Any],
    owncloud_gwemopt_url: str,
    id_gw_alert_db: int,
    path_output: str,
    path_log: str,
    threshold_config: dict[str, float | int],
    obs_strategy: str,
    alert_thread_ts: str | None = None,
    path_galaxy_catalog: str | None = None,
    galaxy_catalog: str | None = None,
) -> tuple[str, tuple[str, str]]:
    """
    Task to process a GCN (General Coordinates Network) notice and generate observation plans using the GWEMOPT package for the GRANDMA collaboration.

    This Celery task orchestrates the full workflow for a gravitational wave alert: it parses the alert, generates observation plans (tilings) for a list of telescopes, pushes the results to an ownCloud instance, and posts updates to Slack. The process is highly configurable and adapts its behavior depending on the observation strategy (tiling type) selected.

    Context and Workflow
    --------------------
    - The task is triggered when a new GCN notice is received. It is designed to be run asynchronously as part of a distributed system.
    - The notice is parsed and a GW_alert object is created, which encapsulates the alert's metadata and skymap.
    - The observation strategy (tiling type) determines the downstream processing:
        * For standard tiling, the skymap is divided into tiles for each telescope, maximizing coverage.
        * For galaxy-targeted tiling (GALAXYTARGETING), the process cross-matches the skymap with a galaxy catalog to prioritize tiles containing likely host galaxies. In this case, both a galaxy catalog path and a catalog object must be provided.
    - The GWEMOPT package is used to generate the observation plan, which may include 2D or 3D tiling, galaxy targeting, and additional features such as observability and footprint plots.
    - The results (plots, data files, and custom ASCII tables) are uploaded to an ownCloud instance for sharing with the collaboration.
    - Slack notifications are sent at key steps: task start, plan generation, and result posting (including coverage maps and ASCII tables).
    - After completion, a post-processing task can merge galaxy-targeted results and clean up temporary files.

    Parameters
    ----------
    session : Session
        SQLAlchemy session for database interactions. This is used to retrieve the GW alert from the database.
    telescopes : list[str]
        List of telescope names to use for the observation plan. Each telescope will receive a tailored tiling.
    nb_tiles : list[int]
        Number of tiles to generate for each telescope. Must match the length of `telescopes`.
    nside : int
        The HEALPix nside parameter for the skymap resolution.
    slack_channel : str
        The Slack channel name where notifications and results will be posted.
    channel_id : str
        The Slack channel ID (used by the Slack API for posting images and threaded messages).
    owncloud_config : dict[str, Any]
        Configuration dictionary for the ownCloud client, containing credentials and connection info.
    owncloud_gwemopt_url : str
        The base URL for the ownCloud instance where results will be stored. Subfolders are created per event and strategy.
    id_gw_alert_db : int
        The ID of the GW alert in the database. This is used to retrieve the alert information.
    path_output : str
        Path to the output directory where GWEMOPT products (plots, data files) will be written.
    path_log : str
        Path to the directory where log files for this task will be stored.
    threshold_config : dict[str, float | int]
        Dictionary of thresholds (e.g., probability, area) to use in the GW_alert and GWEMOPT processing.
    obs_strategy : str
        The observation strategy (tiling type) to use. Should be one of the values in `GW_alert.ObservationStrategy` (e.g., STANDARD, GALAXYTARGETING).
    alert_thread_ts : str | None, optional
        Slack thread timestamp for posting follow-up messages in a thread (if applicable).
    path_galaxy_catalog : str | None, optional
        Path to the galaxy catalog directory. Required for galaxy-targeted tiling.
    galaxy_catalog : str | None, optional
        The galaxy catalog to use (as a string identifier or object). Required for galaxy-targeted tiling.

    Returns
    -------
    tuple[str, tuple[str, str]]
        - The path to the output directory where the results are stored.
        - A tuple containing the path to the galaxy tiles (if applicable) and the ownCloud URL where the results are stored.

    Notes
    -----
    - The task is robust to missing or malformed input, and logs errors for debugging.
    - The workflow is modular: each step (parsing, tiling, upload, notification) can be adapted or extended for new strategies or output formats.
    - The output structure on ownCloud is organized by event and strategy, making it easy to find results for a given alert and tiling type.
    - For galaxy-targeted tiling, a post-processing step merges all ASCII tables into a single file for the collaboration.
    """

    task_id = current_task.request.id
    logger, log_file_path = setup_task_logger(
        f"gwemopt_task_{task_id}", Path(path_log), task_id
    )

    # Initialize the ownCloud client and URL
    owncloud_client = OwncloudClient(owncloud_config)
    owncloud_gwemopt_url = URL(owncloud_gwemopt_url)

    obs_strategy: GW_alert.ObservationStrategy = (
        GW_alert.ObservationStrategy.from_string(obs_strategy)
    )
    if obs_strategy == GW_alert.ObservationStrategy.GALAXYTARGETING and (
        path_galaxy_catalog is None or galaxy_catalog is None
    ):
        raise ValueError(
            "Observation strategy is set to GALAXYTARGETING but no galaxy catalog path or galaxy catalog provided."
        )

    alert_url_subpart = owncloud_client.get_url_subpart(owncloud_gwemopt_url, 5)
    obs_strategy_owncloud_path = (
        alert_url_subpart + f"/{obs_strategy.name}_{"_".join(telescopes)}"
    )
    # create specific observation strategy owncloud folder
    obs_strategy_owncloud_url_folder = owncloud_client.mkdir(obs_strategy_owncloud_path)

    start_task = Time.now()
    output_path = Path(path_output)
    path_galaxy_catalog = Path(path_galaxy_catalog) if path_galaxy_catalog else None
    galaxy_catalog = (
        GalaxyCatalog.from_string(galaxy_catalog) if galaxy_catalog else None
    )

    try:

        # Retrieve the GW_alert from the database using the provided ID
        logger.info(f"Retrieving GW_alert with ID {id_gw_alert_db} from the database.")
        gw_alert_db = session.query(GWDB_alert).get(id_gw_alert_db)
        gw_alert = GW_alert.from_db_model(gw_alert_db, thresholds=threshold_config)
        logger.info(f"GW_alert {gw_alert.event_id} retrieved successfully.")

        with open(log_file_path, "a") as log_file:
            with redirect_stdout(log_file), redirect_stderr(log_file):
                logger.info("Starting gwemopt_task...")

                worker_slack_client = init_slackbot(logger)

                # Send a message to Slack to inform that a gwemopt task is starting
                new_alert_on_slack(
                    gw_alert,
                    build_gwemopt_message,
                    worker_slack_client,
                    channel=slack_channel,
                    logger=logger,
                    thread_ts=alert_thread_ts,
                    obs_strategy=obs_strategy,
                    celery_task_id=task_id,
                    task_start_time=start_task,
                    telescopes=telescopes,
                )

                tiles, _ = run_gwemopt(
                    gw_alert,
                    telescopes,
                    nb_tiles,
                    nside=nside,
                    path_output=output_path,
                    observation_strategy=obs_strategy,
                    logger=logger,
                    path_galaxy_catalog=path_galaxy_catalog,
                    galaxy_catalog=galaxy_catalog,
                )

                # create the owncloud folder for the gwemopt plots and data files
                logger.info("Pushing gwemopt products to ownCloud...")
                plots_owncloud_url_folder = owncloud_client.mkdir(
                    obs_strategy_owncloud_path + "/plots"
                )
                push_gwemopt_product_on_owncloud(
                    owncloud_client,
                    output_path,
                    plots_owncloud_url_folder,
                    pattern="*.png",
                )

                logger.info("Successfully pushed plots to ownCloud.")

                push_gwemopt_product_on_owncloud(
                    owncloud_client,
                    output_path,
                    plots_owncloud_url_folder,
                    pattern="*.dat",
                )

                logger.info("Successfully pushed data files to ownCloud.")

                ascii_tiles_path = output_path / "tiles_ascii.txt"
                # Upload the tiles table in custom ASCII format to ownCloud
                for k, v in tiles.items():
                    gwemopt_ascii_tiles = table_to_custom_ascii(k, v)

                    # write the ASCII tiles to a file
                    with open(ascii_tiles_path, "w") as f:
                        f.write(gwemopt_ascii_tiles)

                    owncloud_client.put_data(
                        data=gwemopt_ascii_tiles.encode("utf-8"),
                        url=obs_strategy_owncloud_url_folder,
                        owncloud_filename=f"tiles_{k}.txt",
                    )

                logger.info(
                    "Tiles table converted to custom ASCII format and uploaded to ownCloud."
                )

                logger.info("GW_alert successfully processed.")

                # Post the gwemopt result message on Slack
                gwemopt_result_response = new_alert_on_slack(
                    gw_alert,
                    build_gwemopt_results_message,
                    worker_slack_client,
                    channel=slack_channel,
                    logger=logger,
                    thread_ts=alert_thread_ts,
                    tiles_plan=tiles,
                    celery_task_id=task_id,
                    execution_time=(Time.now() - start_task).sec,
                    obs_strategy=obs_strategy,
                    telescopes=telescopes,
                    path_gw_alert=obs_strategy_owncloud_path,
                )

                logger.info("gwemopt post message successfully sent to Slack.")

                try:
                    # Post the coverage map on Slack
                    post_image_on_slack(
                        worker_slack_client,
                        filepath=output_path / "tiles_coverage_int.png",
                        filetitle=f"{gw_alert.event_id} {obs_strategy.value} {"_".join(telescopes)} Coverage Map",
                        filename=f"coverage_{gw_alert.event_id}_{obs_strategy.value}_map.png",
                        channel_id=channel_id,
                        threads_ts=gwemopt_result_response["ts"],
                    )
                except FileNotFoundError as e:
                    logger.error(
                        f"Coverage map file not found: {e}. Skipping posting map on Slack."
                    )
                    raise e

                logger.info("Coverage map posted on slack in the message thread")

    except Exception as e:
        logger.error(f"An error occurred while processing the task: {e}")
        raise e

    # Return the paths to the galaxy tiles file in order to merge them later and create the 'ALL.txt' file
    path_galaxy_tiles = (
        str(ascii_tiles_path)
        if obs_strategy == GW_alert.ObservationStrategy.GALAXYTARGETING
        else None
    )
    return (
        str(output_path),
        (path_galaxy_tiles, str(obs_strategy_owncloud_url_folder)),
    )


def merge_galaxy_file(
    owncloud_config: dict[str, Any],
    obs_strategy_owncloud_url_folder: URL,
    ascii_file_path: list[str],
):
    """
    Merge the galaxy targeting results from the output directory into a single file named 'ALL.txt'.
    The file is then send to the ownCloud instance.
    This function is intended to be run after the gwemopt task has completed.

    Parameters
    ----------
    obs_strategy_owncloud_url_folder : str
        The URL of the ownCloud folder where the merged file will be uploaded.
    owncloud_config : dict[str, Any]
        Configuration dictionary for the ownCloud client, containing the username and password.
    ascii_file_path : list[str]
        List of paths to the ASCII files containing the galaxy targeting results.
    """
    # Initialize the ownCloud client and URL
    owncloud_client = OwncloudClient(owncloud_config)
    obs_strategy_owncloud_url_folder = URL(obs_strategy_owncloud_url_folder)

    merge_results = []
    # Implementation goes here
    for path in ascii_file_path:
        path = Path(path)
        if not path.exists():
            raise FileNotFoundError(f"The path {path} does not exist.")
        with open(path) as f:
            merge_results.append(f.read())

    all_ascii = "\n\n".join(merge_results)

    owncloud_client.put_data(
        data=all_ascii.encode("utf-8"),
        url=obs_strategy_owncloud_url_folder,
        owncloud_filename="ALL.txt",
    )


@celery.task(name="gwemopt_post_task")
def gwemopt_post_task(
    results: tuple[str, str, tuple[str, str]], owncloud_config: dict[str, Any]
) -> None:
    """
    Task to clean up after the gwemopt task has completed.
    This task removes the notice file and the output directory created by the gwemopt task.

    Parameters
    ----------
    results : tuple[str, str, tuple[str, str]]
        A tuple containing the path to the notice file and the path to the output directory.
    owncloud_config : dict[str, Any]
        Configuration dictionary for the ownCloud client, containing the username and password.
    path_log : str
        Path to the log directory where the task logs will be stored.
    """

    # results is a list of tuples (path_gwemopt_output, (path_ascii, obs_strategy_owncloud_url_folder))
    path_ascii = [
        path_ascii for _, (path_ascii, _) in results if path_ascii is not None
    ]
    owncloud_url = URL(results[0][1][1]).parent
    if len(path_ascii) > 0:
        # merge the galaxy targeting results into a single file named 'ALL.txt'
        # and upload it to the ownCloud instance
        merge_galaxy_file(
            owncloud_config=owncloud_config,
            obs_strategy_owncloud_url_folder=owncloud_url,
            ascii_file_path=path_ascii,
        )

    for _, path_gwemopt_output, _ in results:
        folder_gwemopt_output = Path(path_gwemopt_output)
        # remove the output directory after processing
        if folder_gwemopt_output.exists() and folder_gwemopt_output.is_dir():
            shutil.rmtree(folder_gwemopt_output)
