from pathlib import Path
from fink_utils.slack_bot.bot import init_slackbot

from grandma_gcn.gcn_stream.gw_alert import GW_alert
from grandma_gcn.slackbot.gw_message import (
    build_gwemopt_results_message,
    new_alert_on_slack,
    build_gwemopt_message,
    post_image_on_slack,
)
from grandma_gcn.worker.celery_app import celery
import logging
from celery import current_task

from astropy.time import Time

from grandma_gcn.worker.gwemopt_init import GalaxyCatalog, init_gwemopt
from contextlib import redirect_stdout, redirect_stderr


def setup_task_logger(
    task_name: str, log_path: Path, task_id: str
) -> tuple[logging.Logger, Path]:
    """
    Configure a logger to log into a separate file for each task.

    Parameters
    ----------
    task_name : str
        The name of the task.
    log_path : Path
        The path where the log files will be stored.
    task_id : str
        The unique identifier for the task, used to create a unique log file name.

    Returns
    -------
    tuple[logging.Logger, Path]
        A tuple containing the logger and the path to the log file.
    """
    logger = logging.getLogger(f"gcn_stream.consumer.worker.{task_id}")
    logger.setLevel(logging.INFO)

    # Create a file handler for the task
    log_file = log_path / f"{task_name}_{task_id}.log"
    log_file.parent.mkdir(
        parents=True, exist_ok=True
    )  # Create the logs directory if it doesn't exist
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(logging.INFO)

    # Create a formatter and add it to the handler
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    file_handler.setFormatter(formatter)

    # Add the handler to the logger
    if not logger.handlers:  # Avoid adding multiple handlers
        logger.addHandler(file_handler)

    return logger, log_file


def run_gwemopt(
    gw_alert: GW_alert,
    telescopes: list[str],
    nb_tiles: list[str],
    nside: int,
    path_output: Path,
    observation_strategy: GW_alert.ObservationStrategy,
    logger: logging.Logger,
    path_galaxy_catalog: Path | None,
    galaxy_catalog: GalaxyCatalog | None,
) -> None:
    """
    Run the gwemopt observation plan.

    Parameters
    ----------
    gw_alert : GW_alert
        The GW_alert object containing the alert information.
    telescopes : list[str]
        List of telescopes to use for the observation plan.
    nside : int
        The nside parameter for the skymap.
    path_output : Path
        Path to the output directory.
    observation_strategy : GW_alert.ObservationStrategy
        The observation strategy to use.
    logger : logging.Logger
        Logger to use for logging. If None, a new logger will be created.
    path_galaxy_catalog : Path | None
        Path to the galaxy catalog directory.
    galaxy_catalog : GalaxyCatalog | None
        The galaxy catalog to use.

    Returns
    -------
    tuple[Table, Any]
        - tiles_tables: the table of tiles generated by gwemopt
        - galaxies_table: the table of galaxies generated by gwemopt
    """
    logger.info("Flattening the skymap...")
    flat_map = gw_alert.flatten_skymap(nside)
    logger.info("Flat map created. Initializing gwemopt...")

    params, map_struct = init_gwemopt(
        flat_map,
        convert_to_nested=False,
        exposure_time=[30 for _ in range(len(nb_tiles))],
        max_nb_tile=nb_tiles,
        nside=nside,
        do_3d=False,
        do_plot=True,
        do_observability=True,
        do_footprint=True,
        do_movie=True,
        moon_check=False,
        do_reference=True,
        path_catalog=path_galaxy_catalog,
        galaxy_catalog=galaxy_catalog,
    )

    logger.info("gwemopt initialized. Running observation plan...")
    obs_plan_results = gw_alert.run_observation_plan(
        telescopes,
        params,
        map_struct,
        str(path_output),
        observation_strategy,
    )
    logger.info("Observation plan completed.")

    return obs_plan_results


def table_to_custom_ascii(telescope, table):
    """
    Convert a table returned by gwemopt to a custom ASCII format for the grandma owncloud.

    Parameters
    ----------
    telescope : str
        The name of the telescope.
    table : Table
        The table containing the observation plan data.

    Returns
    -------
    str
        The formatted string in the custom ASCII format.
    """
    lines = [f"# {telescope}"]
    lines.append("rank_id       tile_id       RA       DEC       Prob   Timeobs")

    if not table:
        lines.append("# No tiles to observe")
        return "\n".join(lines)

    for row in table:
        rank_id = row["rank_id"]
        tile_id = row["tile_id"]
        ra = row["RA"] * 180 / 3.141592653589793  # rad → deg
        dec = row["DEC"] * 180 / 3.141592653589793  # rad → deg
        prob = row["Prob"]
        timeobs = Time(row["Timeobs"]).iso  # format ISO, eg. 2025-05-27 08:49:22.577

        # truncate ms to 3 digits
        timeobs = timeobs[:23]

        # Format the line with fixed spacing
        line = (
            f"{rank_id:<4} {tile_id:<8} {ra:<10.4f} {dec:<10.4f} {prob:<8.4f} {timeobs}"
        )
        lines.append(line)

    return "\n".join(lines)


@celery.task(name="gwemopt_task")
def gwemopt_task(
    telescopes: list[str],
    nb_tiles: list[int],
    nside: int,
    slack_channel: str,
    channel_id: str,
    path_notice: str,
    path_output: str,
    path_log: str,
    BBH_threshold: float,
    Distance_threshold: float,
    ErrorRegion_threshold: float,
    obs_strategy: str,
    path_galaxy_catalog: str | None = None,
    galaxy_catalog: str | None = None,
) -> None:
    """
    Task to process the GCN notice.

    Parameters
    ----------
    telescopes : listpath_log[str]
        List of telescopes to use for the observation plan.
    nb_tiles : list[int]
        Number of tiles for each telescope.
    nside : int
        The nside parameter for the skymap.
    slack_channel : str
        The Slack channel to send the notification to.
    channel_id : str
        The Slack channel ID to send the notification to.
        Different from slack_channel, this is the ID used by the Slack API.
    path_output : str
        Path to the output directory.
    path_notice : str
        Path to the GCN notice file.
    BBH_threshold : float
        Threshold for BBH probability.
    Distance_threshold : float
        Threshold for distance cut.
    ErrorRegion_threshold : float
        Threshold for size region cut.
    path_galaxy_catalog : str
        Path to the galaxy catalog directory.
    galaxy_catalog : str
        The galaxy catalog to use.
    """
    obs_strategy = GW_alert.ObservationStrategy.from_string(obs_strategy)
    if obs_strategy == GW_alert.ObservationStrategy.GALAXYTARGETING and (
        path_galaxy_catalog is None or galaxy_catalog is None
    ):
        raise ValueError(
            "Observation strategy is set to GALAXYTARGETING but no galaxy catalog path or galaxy catalog provided."
        )

    start_task = Time.now()
    task_id = current_task.request.id
    path_notice = Path(path_notice)
    output_path = Path(path_output)
    path_galaxy_catalog = Path(path_galaxy_catalog) if path_galaxy_catalog else None
    galaxy_catalog = (
        GalaxyCatalog.from_string(galaxy_catalog) if galaxy_catalog else None
    )

    try:
        with open(path_notice, "rb") as fp:
            json_byte = fp.read()

        gw_alert = GW_alert(
            json_byte,
            BBH_threshold=BBH_threshold,
            Distance_threshold=Distance_threshold,
            ErrorRegion_threshold=ErrorRegion_threshold,
        )  # Configure a logger specific to this task

        logger, log_file_path = setup_task_logger(
            "gwemopt_task_{}".format(gw_alert.event_id), Path(path_log), task_id
        )

        with open(log_file_path, "a") as log_file:
            with redirect_stdout(log_file), redirect_stderr(log_file):
                logger.info("Starting gwemopt_task...")

                worker_slack_client = init_slackbot(logger)

                new_alert_on_slack(
                    gw_alert,
                    build_gwemopt_message,
                    worker_slack_client,
                    channel=slack_channel,
                    logger=logger,
                    obs_strategy=obs_strategy,
                    celery_task_id=task_id,
                    task_start_time=start_task,
                    telescopes=telescopes,
                )

                tiles, galaxy = run_gwemopt(
                    gw_alert,
                    telescopes,
                    nb_tiles,
                    nside=nside,
                    path_output=output_path,
                    observation_strategy=obs_strategy,
                    logger=logger,
                    path_galaxy_catalog=path_galaxy_catalog,
                    galaxy_catalog=galaxy_catalog,
                )

                print(f"Tiles: {tiles}")

                print()
                print()

                print(f"Galaxy: {galaxy}")

                # import pickle

                # with open(output_path / "tiles.pickle", "wb") as f:
                #     pickle.dump(tiles, f)

                # with open(output_path / "galaxy.pickle", "wb") as f:
                #     pickle.dump(galaxy, f)

                _ = {k: table_to_custom_ascii(k, v) for k, v in tiles.items()}

                # with open(output_path / "ascii_res.pickle", "wb") as f:
                #     pickle.dump(ascii_results, f)

                logger.info("GW_alert successfully processed.")

                permalink = post_image_on_slack(
                    worker_slack_client,
                    filepath=output_path / "tiles_coverage_int.png",
                    filetitle=f"{gw_alert.event_id} {obs_strategy.value} Coverage Map",
                    filename=f"coverage_{gw_alert.event_id}_{obs_strategy.value}_map.png",
                    channel_id=channel_id,
                )

                logger.info(
                    f"Coverage map posted on slack, permalink for coverage map: {permalink}"
                )

                new_alert_on_slack(
                    gw_alert,
                    build_gwemopt_results_message,
                    worker_slack_client,
                    channel=slack_channel,
                    logger=logger,
                    celery_task_id=task_id,
                    execution_time=(Time.now() - start_task).sec,
                    obs_strategy=obs_strategy,
                    telescopes=telescopes,
                    slack_plot_permalink=permalink,
                )

                logger.info("gwemopt post message successfully sent to Slack.")

    except Exception as e:
        logger.error(f"An error occurred while processing the task: {e}")
        raise e


@celery.task(name="gwemopt_post_task")
def gwemopt_post_task(results):
    # results est une liste des retours de chaque gwemopt_task
    print("Post-traitement exécuté après les deux tâches.")
    print("Résultats:", results)
